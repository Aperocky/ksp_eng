RUNONCEPATH("LIB/BASE_LIB.KS").

FUNCTION NODE_EXEC {
    PARAMETER ALLOW_STAGE IS TRUE.
    WAIT 1. // NODE MAY NOT HAVE POPULATED YET
    IF NOT HASNODE {
        PRINT "NO NODE SCHEDULED".
        RETURN.
    }
    CLEARSCREEN.
    SAS OFF.
    LOCAL NODE TO NEXTNODE.
    LOCAL DURATION TO NODE:DELTAV:MAG/(SHIP:MAXTHRUST/SHIP:MASS).
    WARP_TO_TIME(NODE:ETA - DURATION/2 - 20).
    LOCAL HEADING TO NODE:DELTAV.
    LOCK STEERING TO HEADING.
    WAIT NODE:ETA - DURATION/2.

    LOCAL TVAL TO 0.
    LOCK THROTTLE TO TVAL.
    LOCAL OG_NODE_HEADING TO NODE:DELTAV.
    UNTIL FALSE {
        IF STAGE:LIQUIDFUEL < 1 AND ALLOW_STAGE {
            STAGE. WAIT 0.
        }
        LOCAL MAX_ACC TO SHIP:MAXTHRUST/SHIP:MASS.
        SET TVAL TO MIN(NODE:DELTAV:MAG/MAX_ACC, 1).
        SET HEADING TO NODE:DELTAV.
        IF VDOT(OG_NODE_HEADING, NODE:DELTAV) < 0 OR NODE:DELTAV:MAG < 0.1 {
            BREAK.
        }
        PRINT "ALTITUDE:   " + ROUND(SHIP:ALTITUDE) + " METERS    " AT (5,2).
        PRINT "APOAPSIS:   " + ROUND(SHIP:APOAPSIS) + " METERS    " AT (5,3).
        PRINT "PERIAPSIS:  " + ROUND(SHIP:PERIAPSIS) + " METERS    " AT (5,4).
        PRINT "DV LEFT: " + ROUND(NODE:DELTAV:MAG) + " M/S     " AT (5,5).
    }
    SET TVAL TO 0.
    UNLOCK STEERING.
    UNLOCK THROTTLE.
    SET THROTTLE TO 0.
    WAIT 0.
    REMOVE NODE.
    CLEARSCREEN.
}

FUNCTION CIRCULARIZE_NODE {
    // USE NODE TO CIRCULARIZE, THIS IS SUPERIOR TO FEEDBACK LOOP CIRCULARIZATION
    PARAMETER AT_APOAPSIS IS TRUE.

    LOCAL CURR_SMA TO (SHIP:APOAPSIS + SHIP:PERIAPSIS)/2 + SHIP:BODY:RADIUS.
    LOCAL GOAL_SMA TO CHOOSE SHIP:APOAPSIS IF AT_APOAPSIS ELSE SHIP:PERIAPSIS.
    SET GOAL_SMA TO GOAL_SMA + SHIP:BODY:RADIUS.
    LOCAL BASE_V TO SQRT(SHIP:BODY:MU * (2/GOAL_SMA - 1/CURR_SMA)).
    LOCAL GOAL_V TO SQRT(SHIP:BODY:MU/GOAL_SMA).

    LOCAL WAIT_TIME TO CHOOSE ETA:APOAPSIS IF AT_APOAPSIS ELSE ETA:PERIAPSIS.
    ADD NODE(TIME:SECONDS + WAIT_TIME, 0, 0, GOAL_V - BASE_V).
}

FUNCTION ADJUST_PERIAPSIS {
    // ADJUSTING PERIAPSIS AT APOAPSIS, USE FOR ATMOSPHERIC BLEEDING AND OTHER STUFF
    PARAMETER TARGET_PERIAPSIS IS 42500. // KERBIN
    LOCAL CURR_SMA TO (SHIP:APOAPSIS + SHIP:PERIAPSIS)/2 + SHIP:BODY:RADIUS.
    LOCAL GOAL_SMA TO (SHIP:APOAPSIS + TARGET_PERIAPSIS)/2 + SHIP:BODY:RADIUS.
    LOCAL BASE_V TO SQRT(SHIP:BODY:MU * (2/(SHIP:APOAPSIS + SHIP:BODY:RADIUS) - 1/CURR_SMA)).
    LOCAL GOAL_V TO SQRT(SHIP:BODY:MU * (2/(SHIP:APOAPSIS + SHIP:BODY:RADIUS) - 1/GOAL_SMA)).
    LOCAL WAIT_TIME TO ETA:APOAPSIS.
    ADD NODE(TIME:SECONDS + WAIT_TIME, 0, 0, GOAL_V - BASE_V).
}

FUNCTION ADJUST_APOAPSIS {
    // ADJUSTING APOAPSIS AT PERIAPSIS, REVERSE OF ADJUST_PERIAPSIS
    PARAMETER TARGET_APOAPSIS.
    LOCAL CURR_SMA TO (SHIP:APOAPSIS + SHIP:PERIAPSIS)/2 + SHIP:BODY:RADIUS.
    LOCAL GOAL_SMA TO (SHIP:PERIAPSIS + TARGET_APOAPSIS)/2 + SHIP:BODY:RADIUS.
    LOCAL BASE_V TO SQRT(SHIP:BODY:MU * (2/(SHIP:PERIAPSIS + SHIP:BODY:RADIUS) - 1/CURR_SMA)).
    LOCAL GOAL_V TO SQRT(SHIP:BODY:MU * (2/(SHIP:PERIAPSIS + SHIP:BODY:RADIUS) - 1/GOAL_SMA)).
    LOCAL WAIT_TIME TO ETA:PERIAPSIS.
    ADD NODE(TIME:SECONDS + WAIT_TIME, 0, 0, GOAL_V - BASE_V).
}

FUNCTION HOHMANN_TRANSFER {
    // ASSUMES STARTING FROM CICULAR PROGRADE ORBIT OF NO INCLINATION
    PARAMETER AP_GOAL. // TARGET APOAPSIS/PERIAPSIS ALTITUDE.
    PARAMETER WAIT_TIME. // WAIT FOR X SECONDS BEFORE FIRING
    UNTIL NOT HASNODE {
        REMOVE NEXTNODE.
        WAIT 1.
    }

    LOCAL CURR_SMA TO (SHIP:APOAPSIS + SHIP:PERIAPSIS)/2 + SHIP:BODY:RADIUS.
    LOCAL GOAL_SMA TO (AP_GOAL + SHIP:BODY:RADIUS + CURR_SMA)/2.
    LOCAL BASE_V TO SQRT(SHIP:BODY:MU/CURR_SMA).
    LOCAL GOAL_V TO SQRT(SHIP:BODY:MU * (2/CURR_SMA - 1/GOAL_SMA)).
    ADD NODE(TIME:SECONDS + WAIT_TIME, 0, 0, GOAL_V - BASE_V).
}

FUNCTION GET_INCLINATION {
    // GET INCLINATION BETWEEN TARGET ORBIT AND CURRENT ORBIT
    IF NOT HASTARGET {
        PRINT("NO TARGET").
        RETURN.
    }

    LOCAL SP TO SHIP:POSITION - BODY:POSITION.
    LOCAL TP TO TARGET:POSITION - BODY:POSITION.
    LOCAL SN TO VCRS(SP, SHIP:VELOCITY:ORBIT):NORMALIZED.
    LOCAL TN TO VCRS(TP, TARGET:VELOCITY:ORBIT):NORMALIZED.
    LOCAL AN_DN TO VCRS(TN, SN). // THIS POINTS TO DESCENDING NODE
    LOCAL INC TO VANG(SN, TN).
    LOCAL PHASE TO VANG(SP, AN_DN).

    LOCAL SN90 TO VCRS(SN, SP):NORMALIZED.
    LOCAL SIGN TO VDOT(SN90, AN_DN) > 0.
    IF NOT(SIGN) {
        SET PHASE TO -PHASE.
    }
    PRINT("INCLINATION IS " + ROUND(INC, 2) + " DEGREES").
    PRINT("PHASE IS " + ROUND(PHASE, 2) + " DEGREES").
    RETURN LIST(INC, PHASE).
}

FUNCTION MATCH_INCLINATION {
    // THIS ASSUME CIRCULAR ORBIT
    IF NOT HASTARGET {
        PRINT("NO TARGET").
        RETURN.
    }

    LOCAL INC_PARAMS TO GET_INCLINATION().
    LOCAL INC TO INC_PARAMS[0].
    LOCAL PHASE TO INC_PARAMS[1].
    IF INC < 0.1 {
        PRINT "INCLINATION ALREADY MATCHED, NO NEED TO ADJUST".
        RETURN.
    }
    IF PHASE < 0 {
        SET PHASE TO PHASE + 360.
    }
    LOCAL WAIT_TIME TO PHASE * SHIP:ORBIT:PERIOD / 360.
    LOCAL CURR_SMA TO (SHIP:APOAPSIS + SHIP:PERIAPSIS)/2 + SHIP:BODY:RADIUS.
    LOCAL ORBIT_VELOCITY TO SQRT(SHIP:BODY:MU/CURR_SMA).

    LOCAL ADJUST_VELOCITY TO ORBIT_VELOCITY * SIN(INC).
    ADD NODE(TIME:SECONDS + WAIT_TIME, 0, ADJUST_VELOCITY, 0).
}

FUNCTION GET_PHASE_ANGLE {
    IF NOT HASTARGET {
        PRINT("NO TARGET").
        RETURN.
    }
    LOCAL SP TO SHIP:POSITION - BODY:POSITION.
    LOCAL TP TO TARGET:POSITION - BODY:POSITION.
    LOCAL SN TO VCRS(SP, SHIP:VELOCITY:ORBIT):NORMALIZED.
    LOCAL SN90 TO VCRS(SN, SP):NORMALIZED.
    LOCAL T_SN TO VXCL(SN, TP).
    LOCAL SIGN TO VDOT(SN90, T_SN) > 0.
    LOCAL PHASE_ANGLE TO VANG(SP, T_SN).
    IF SIGN {
        RETURN PHASE_ANGLE.
    }
    RETURN -PHASE_ANGLE.
}

FUNCTION HOHMANN_RENDEZVOUS_ANGLE {
    // A * P0 = (A + A0) * P1 + T0.
    // A * P0 = A * P1 + A0 * P1 + T0.
    // A * (P0 - P1) = A0 * P1 + T0.
    // A = (A0 * P1 + T0)/(P0 - P1).
    // A: ANGLE OF RENDEZVOUS (TARGET)
    // A0: PHASE ANGLE + 180 DEG.
    // P0: TARGET ORBITAL PERIOD.
    // P1: ORIGIN ORBITAL PERIOD.
    // T0: HOHMANN TRANSFER TIME

    PARAMETER ANGDIFF IS 0.
    IF NOT HASTARGET {
        PRINT("NO TARGET").
        RETURN.
    }

    LOCAL P0 TO TARGET:ORBIT:PERIOD.
    LOCAL P1 TO SHIP:ORBIT:PERIOD.
    LOCAL A0 TO (GET_PHASE_ANGLE() - 180)/360.
    LOCAL HTSMA TO (SHIP:ORBIT:SEMIMAJORAXIS + TARGET:ORBIT:SEMIMAJORAXIS)/2.
    LOCAL T0 TO CONSTANT:PI * SQRT(HTSMA^3/BODY:MU).
    LOCAL ANGLE TO (A0 * P1 + T0 + ANGDIFF/360 * P0)/(P0 - P1).
    LOCAL RESULT TO ANGLE + A0.
    LOCAL TOADD TO 0.

    UNTIL RESULT > 0 {
        IF P0 > P1 {
            PRINT "ADDING ANOTHER FULL ORIGIN ORBIT TO RENDEZVOUS".
            SET A0 TO A0 + 1.
            SET ANGLE TO (A0 * P1 + T0 + ANGDIFF/360 * P0)/(P0 - P1).
            SET RESULT TO ANGLE + A0.
        } ELSE {
            PRINT "ADDING ANOTHER FULL TARGET ORBIT TO RENDEZVOUS".
            SET TOADD TO TOADD + 1.
            SET ANGLE TO (A0 * P1 + T0 + ANGDIFF/360 * P0 - TOADD * P0)/(P0 - P1).
            SET RESULT TO ANGLE + A0.
        }
    }
    // ANGLE RETURNED IS IN FRACTION OF FULL ORBIT
    RETURN RESULT.
}

FUNCTION HOHMANN_TRANSFER_TARGET {
    PARAMETER ANGDIFF IS 0.
    LOCAL NODE_ANG TO HOHMANN_RENDEZVOUS_ANGLE(ANGDIFF).
    LOCAL NODE_TIME TO NODE_ANG * SHIP:ORBIT:PERIOD.
    HOHMANN_TRANSFER(TARGET:ORBIT:SEMIMAJORAXIS-BODY:RADIUS, NODE_TIME).
}

FUNCTION DEORBIT_KSC_NODE {
    // ASSUME CIRCULAR EQUATORIAL ORBIT.
    // USE APPROXIMATE ORBITAL MECHANICS TO AIM AT KSC.
    // KSC OCEAN LANDING LONGITUDE == -75.

    // ORBITAL ALTITUDE AT KSC IF VACUUM
    LOCAL KSC_ALT_ADJUST TO LN(MASS/10)*1000.
    LOCAL KSC_ALT TO 40000 - KSC_ALT_ADJUST.
    LOCAL ORBIT_HEIGHT TO (SHIP:APOAPSIS + SHIP:PERIAPSIS)/2.
    LOCAL DEORBIT_FRACTION TO KSC_ALT/ORBIT_HEIGHT.

    // CALCULATE DELTAV AT DEORBIT.
    LOCAL CURR_SMA TO ORBIT_HEIGHT + SHIP:BODY:RADIUS.
    LOCAL GOAL_SMA TO ORBIT_HEIGHT/2 + SHIP:BODY:RADIUS.
    LOCAL BASE_V TO SQRT(SHIP:BODY:MU/CURR_SMA).
    LOCAL GOAL_V TO SQRT(SHIP:BODY:MU * (2/CURR_SMA - 1/GOAL_SMA)).

    // CALCULATE WAIT TIME TO DEORBIT
    LOCAL ANGLE_AHEAD TO (1 - DEORBIT_FRACTION) * 180. // DEORBIT LNG AHEAD OF KSC.
    PRINT "ANGLE_AHEAD: " + ROUND(ANGLE_AHEAD).
    LOCAL RWA TO 105 - ANGLE_AHEAD + 180 - SHIP:GEOPOSITION:LNG.
    PRINT "RAW WAIT ANGLE: " + ROUND(RWA).
    LOCAL KRA TO (RWA * ORBIT:PERIOD)/21600.
    PRINT "KERBIN ROTATION ADJUST: " + ROUND(KRA).
    LOCAL FWA TO RWA + KRA * (1 + KRA/RWA).
    PRINT "FINAL WAIT ANGLE: " + ROUND(FWA).
    LOCAL WAIT_TIME TO FWA/360 * ORBIT:PERIOD.

    ADD NODE(TIME:SECONDS + WAIT_TIME, 0, 0, GOAL_V - BASE_V).
}
